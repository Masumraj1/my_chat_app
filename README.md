# my_chat_app

1. Chat List Screen
2. Individual Chat Screen
3. Message Bubbles
4. Input Field & Action Bar
5. User Status Indicator
6. Timestamp & Read Receipts
7. Typing Indicator:
8. Scroll to Bottom
9. Sticky Header:

10. 



## ============Learn (_initSocket)================
* ১. প্রথমে Socket কানেক্ট করো: WebSocketChannel.connect দিয়ে সার্ভারের সাথে ডিজিটাল পাইপলাইন তৈরি করা।
* ২. পরিচয় দাও (Join): সার্ভারকে জানানো কোন ইউজার জয়েন করছে, যাতে একজনের মেসেজ ভুল করে আরেকজনের কাছে চলে না যায়।
* ৩. শুনতে থাকো (Listen): stream.listen দিয়ে সারাক্ষণ কান পেতে থাকা যে সার্ভার থেকে কোনো নতুন মেসেজ বা পরিবর্তন আসছে কি না।
* ৪. ডাটা আসলে মডেল বানাও: সকেট থেকে আসা জটিল ডাটাকে MessageModel-এ সাজিয়ে নেওয়া, কারণ মডেল না বানালে অ্যাপ ডাটাগুলো পড়তে বা চিনতে পারবে না।
* ৫. স্টেট আপডেট করে ইউজারকে দেখাও: রিভারপড স্টেট আপডেট করা যাতে মেসেজটি স্ক্রিনে ভেসে ওঠে এবং ইউজার দেখতে পায়।

### কানেক্ট হও → পরিচয় দাও → শুনতে থাকো → মডেল বানাও → স্টেট আপডেট করো।

## ============ Learn (Auto-Scroll on Start) ============
* ১. ডাটা আসার সাথে সাথে চেক (Initial Load): আপনার build মেথড-এর data: (messages)-এর ভেতরে এই লাইনটি খেয়াল করুন: if (messages.isNotEmpty) _scrollToBottom();
* ২. ইউজার এক্সপেরিয়েন্স (UX): চ্যাট অ্যাপে আমরা সবসময় চাই পুরনো মেসেজের চেয়ে সবশেষ (Latest) মেসেজটি আগে দেখতে।
* ৩. ফ্রেম কলব্যাক-এর জাদু (Frame Callback): আপনার _scrollToBottom মেথডে addPostFrameCallback ব্যবহার করা হয়েছে।

## ============ Learn (Notifier Build Flow) ============
* ১. পুরনো খবর সংগ্রহ (_fetchHistory): অ্যাপ খোলার সাথে সাথে ডাটাবেস (API) থেকে আগের সব মেসেজ তুলে আনা।
* ২. সকেটের ঘর খোলা (_initSocket): পুরনো ডাটা আসার ঠিক পরেই রিয়েল-টাইম কানেকশন চালু করা।
* ৩. ডাটা রিটার্ন করা (Return History): সংগৃহীত পুরনো মেসেজগুলো রিভারপডের মাধ্যমে UI-তে পাঠানো।
* ৪. ইউজারকে দেখানো (Display in UI): ref.watch এর মাধ্যমে ইউজার তার মোবাইলে চ্যাট বাবলের লিস্ট দেখতে পায়।


## ============ Learn (addMessage Flow) ============
* ১. ইউজার যখন টাইপ শেষ করে: যখন ইউজার টেক্সট ফিল্ডে কিছু লেখে এবং Send Button-এ ক্লিক করে, তখন এটি কল হয়।
   কেন? সকেট কানেকশন তো শুধু শোনার জন্য নয়, কথা বলার (মেসেজ পাঠানোর) জন্যও ব্যবহার করতে হয়।
* ২. প্যাকেট তৈরি করা (JSON Encode): আপনার লেখা টেক্সটটি সরাসরি পাঠানো যায় না, সেটিকে একটি প্যাকেটে (JSON) ভরতে হয়।
  কেন? সার্ভারকে জানাতে হয়— মেসেজটি কে পাঠাচ্ছে (from), কার কাছে যাবে (to), এবং এটি কী ধরণের কাজ (type: message)।
* ৩. পাইপে ডাটা ঢোকানো (Sink.add): আপনার তৈরি করা প্যাকেটটি _channel.sink.add এর মাধ্যমে সকেট পাইপের ভেতর ঠেলে দেওয়া হয়।
  কেন? এটি করলেই মেসেজটি মুহূর্তের মধ্যে সার্ভারে পৌঁছে যায়।
* ৪. স্ক্রিন ক্লিয়ার ও স্ক্রল: মেসেজটি সেন্ড হওয়ার পর টেক্সট বক্স খালি করা এবং স্ক্রিনটি স্ক্রল করে নিচে নামিয়ে দেওয়া।
কাজ: যাতে ইউজার বুঝতে পারে মেসেজটি পাঠানো হয়েছে।

## ============ Learn (Scroll Flow) ============
* ১. মেকানিজম (The Trigger): ইউজার যখনই সেন্ড বাটনে ক্লিক করে, মেসেজটি সকেটে পাঠানোর পরপরই এই মেথডটি রান হয়।
কেন? যাতে নতুন মেসেজটি লিস্টে যোগ হওয়ার সাথে সাথে স্ক্রিন স্বয়ংক্রিয়ভাবে নিচে নেমে যায়।
* ২. তাৎক্ষণিক অ্যাকশন (Immediate Feedback): আপনি যখন _controller.clear() করেন, তখন ইনপুট ফিল্ড খালি হয় এবং সাথে সাথে স্ক্রল নিচে নামে।
কেন? এটি ইউজারকে একটি স্মুথ ফিল দেয় যে তার মেসেজটি পাঠানো হয়েছে এবং সেটি লিস্টের শেষে আছে।
* ৩. ডাবল সেফটি (Double Check): খেয়াল করুন, আপনি কিন্তু দুই জায়গায় স্ক্রল হ্যান্ডেল করেছেন:
SendMessage-এ: নিজের পাঠানো মেসেজের জন্য।
ref.listen-এ: যখন অন্য কেউ মেসেজ পাঠায় (স্টেট আপডেট হয়), তখনও যেন স্ক্রিন নিচে নামে।

